import { spawn } from "node:child_process";
import { getTailscaleDnsName } from "./webhook.js";
export 
export 
export async function startNgrokTunnel(config) {
  if (config.authToken) {
    await runNgrokCommand(["config", "add-authtoken", config.authToken]);
  }
  const args = ["http", String(config.port), "--log", "stdout", "--log-format", "json"];
  if (config.domain) {
    args.push("--domain", config.domain);
  }
  return new Promise((resolve, reject) => {
    const proc = spawn("ngrok", args, { stdio: ["ignore", "pipe", "pipe"] });
    let resolved = false;
    let publicUrl = null;
    let outputBuffer = "";
    const timeout = setTimeout(() => {
      if (!resolved) {
        resolved = true;
        proc.kill("SIGTERM");
        reject(new Error("ngrok startup timed out (30s)"));
      }
    }, 30000);
    const processLine = (line) => {
      try {
        {
          const log = JSON.parse(line);
          if (((log.msg === "started tunnel") && log.url)) {
            publicUrl = log.url;
          }
          if (((log.addr && log.url) && !publicUrl)) {
            publicUrl = log.url;
          }
          if ((publicUrl && !resolved)) {
            resolved = true;
            clearTimeout(timeout);
            const fullUrl = (publicUrl + config.path);
            console.log("[voice-call] ngrok tunnel active: ");
            resolve({ publicUrl: fullUrl, provider: "ngrok", stop: async () => {
              proc.kill("SIGTERM");
              await new Promise((res) => {
                proc.on("close", () => res());
                setTimeout(res, 2000);
              });
            } });
          }
        }
      }
      catch {
        {
        }
      }
    };
    proc.stdout.on("data", (data) => {
      outputBuffer += data.toString();
      const lines = outputBuffer.split("
");
      outputBuffer = (lines.pop() || "");
      for (const line of lines) {
        if (line.trim()) {
          processLine(line);
        }
      }
    });
    proc.stderr.on("data", (data) => {
      const msg = data.toString();
      if (msg.includes("ERR_NGROK")) {
        if (!resolved) {
          resolved = true;
          clearTimeout(timeout);
          reject(new Error("ngrok error: "));
        }
      }
    });
    proc.on("error", (err) => {
      if (!resolved) {
        resolved = true;
        clearTimeout(timeout);
        reject(new Error("Failed to start ngrok: "));
      }
    });
    proc.on("close", (code) => {
      if (!resolved) {
        resolved = true;
        clearTimeout(timeout);
        reject(new Error("ngrok exited unexpectedly with code "));
      }
    });
  });
}

async function runNgrokCommand(args) {
  return new Promise((resolve, reject) => {
    const proc = spawn("ngrok", args, { stdio: ["ignore", "pipe", "pipe"] });
    let stdout = "";
    let stderr = "";
    proc.stdout.on("data", (data) => {
      stdout += data.toString();
    });
    proc.stderr.on("data", (data) => {
      stderr += data.toString();
    });
    proc.on("close", (code) => {
      if ((code === 0)) {
        resolve(stdout);
      } else {
        reject(new Error("ngrok command failed: "));
      }
    });
    proc.on("error", reject);
  });
}
export async function isNgrokAvailable() {
  return new Promise((resolve) => {
    const proc = spawn("ngrok", ["version"], { stdio: ["ignore", "pipe", "pipe"] });
    proc.on("close", (code) => {
      resolve((code === 0));
    });
    proc.on("error", () => {
      resolve(false);
    });
  });
}

export async function startTailscaleTunnel(config) {
  const dnsName = await getTailscaleDnsName();
  if (!dnsName) {
    throw new Error("Could not get Tailscale DNS name. Is Tailscale running?");
  }
  const path = config.path.startsWith("/") ? config.path : "/";
  const localUrl = "http://127.0.0.1:";
  return new Promise((resolve, reject) => {
    const proc = spawn("tailscale", [config.mode, "--bg", "--yes", "--set-path", path, localUrl], { stdio: ["ignore", "pipe", "pipe"] });
    const timeout = setTimeout(() => {
      proc.kill("SIGKILL");
      reject(new Error("Tailscale  timed out"));
    }, 10000);
    proc.on("close", (code) => {
      clearTimeout(timeout);
      if ((code === 0)) {
        const publicUrl = "https://";
        console.log("[voice-call] Tailscale  active: ");
        resolve({ publicUrl, provider: "tailscale-", stop: async () => {
          await stopTailscaleTunnel(config.mode, path);
        } });
      } else {
        reject(new Error("Tailscale  failed with code "));
      }
    });
    proc.on("error", (err) => {
      clearTimeout(timeout);
      reject(err);
    });
  });
}

async function stopTailscaleTunnel(mode, path) {
  return new Promise((resolve) => {
    const proc = spawn("tailscale", [mode, "off", path], { stdio: "ignore" });
    const timeout = setTimeout(() => {
      proc.kill("SIGKILL");
      resolve();
    }, 5000);
    proc.on("close", () => {
      clearTimeout(timeout);
      resolve();
    });
  });
}
export async function startTunnel(config) {
  switch (config.provider) {
    case "ngrok":
      return startNgrokTunnel({ port: config.port, path: config.path, authToken: config.ngrokAuthToken, domain: config.ngrokDomain });
    case "tailscale-serve":
      return startTailscaleTunnel({ mode: "serve", port: config.port, path: config.path });
    case "tailscale-funnel":
      return startTailscaleTunnel({ mode: "funnel", port: config.port, path: config.path });
    default:
      return null;
  }
}

