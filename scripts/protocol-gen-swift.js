import { promises as fs } from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { ErrorCodes, PROTOCOL_VERSION, ProtocolSchemas } from "../src/gateway/protocol/schema.js";
const __dirname = path.dirname(fileURLToPath(import.meta.url));
const repoRoot = path.resolve(__dirname, "..");
const outPaths = [path.join(repoRoot, "apps", "macos", "Sources", "OpenClawProtocol", "GatewayModels.swift"), path.join(repoRoot, "apps", "shared", "OpenClawKit", "Sources", "OpenClawProtocol", "GatewayModels.swift")];
const header = "// Generated by scripts/protocol-gen-swift.ts â€” do not edit by hand
import Foundation

public let GATEWAY_PROTOCOL_VERSION = 

public enum ErrorCode: String, Codable, Sendable {

}
";
const reserved = new Set(["associatedtype", "class", "deinit", "enum", "extension", "fileprivate", "func", "import", "init", "inout", "internal", "let", "open", "operator", "private", "precedencegroup", "protocol", "public", "rethrows", "static", "struct", "subscript", "typealias", "var"]);
function camelCase(input) {
  return input.replace(/[^a-zA-Z0-9]+/g, " ").trim().toLowerCase().split(/\s+/).map((p, i) => (i === 0) ? p : (p[0].toUpperCase() + p.slice(1))).join("");
}
function safeName(name) {
  const cc = camelCase(name.replace(/-/g, "_"));
  if (reserved.has(cc)) {
    return "_";
  }
  return cc;
}
const schemaNameByObject = new Map();
function swiftType(schema, required) {
  const t = schema.type;
  const isOptional = !required;
  let base;
  const named = schemaNameByObject.get(schema);
  if (named) {
    base = named;
  } else {
    if ((t === "string")) {
      base = "String";
    } else {
      if ((t === "integer")) {
        base = "Int";
      } else {
        if ((t === "number")) {
          base = "Double";
        } else {
          if ((t === "boolean")) {
            base = "Bool";
          } else {
            if ((t === "array")) {
              base = "[]";
            } else {
              if (schema.enum) {
                base = "String";
              } else {
                if (schema.patternProperties) {
                  base = "[String: AnyCodable]";
                } else {
                  if ((t === "object")) {
                    base = "[String: AnyCodable]";
                  } else {
                    base = "AnyCodable";
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return isOptional ? "?" : base;
}
function emitStruct(name, schema) {
  const props = (schema.properties ?? {  });
  const required = new Set((schema.required ?? []));
  const lines = [];
  lines.push("public struct : Codable, Sendable {");
  if ((Object.keys(props).length === 0)) {
    lines.push("}
");
    return lines.join("
");
  }
  const codingKeys = [];
  for (const [key, propSchema] of Object.entries(props)) {
    const propName = safeName(key);
    const propType = swiftType(propSchema, required.has(key));
    lines.push("    public let : ");
    if ((propName !== key)) {
      codingKeys.push("        case  = \"\"");
    } else {
      codingKeys.push("        case ");
    }
  }
  lines.push(((((((("
    public init(
" + Object.entries(props).map(([key, prop]) => {
    const propName = safeName(key);
    const req = required.has(key);
    return "        : ";
  }).join(",
")) + "
    ) {
") + Object.entries(props).map(([key]) => {
    const propName = safeName(key);
    return "        self. = ";
  }).join("
")) + "
    }
") + "    private enum CodingKeys: String, CodingKey {
") + codingKeys.join("
")) + "
    }
}"));
  lines.push("");
  return lines.join("
");
}
function emitGatewayFrame() {
  const cases = ["req", "res", "event"];
  const associated = { req: "RequestFrame", res: "ResponseFrame", event: "EventFrame" };
  const caseLines = cases.map((c) => "    case ()");
  const initLines = "
    private enum CodingKeys: String, CodingKey {
        case type
    }

    public init(from decoder: Decoder) throws {
        let typeContainer = try decoder.container(keyedBy: CodingKeys.self)
        let type = try typeContainer.decode(String.self, forKey: .type)
        switch type {
        case \"req\":
            self = .req(try RequestFrame(from: decoder))
        case \"res\":
            self = .res(try ResponseFrame(from: decoder))
        case \"event\":
            self = .event(try EventFrame(from: decoder))
        default:
            let container = try decoder.singleValueContainer()
            let raw = try container.decode([String: AnyCodable].self)
            self = .unknown(type: type, raw: raw)
        }
    }

    public func encode(to encoder: Encoder) throws {
        switch self {
        case .req(let v): try v.encode(to: encoder)
        case .res(let v): try v.encode(to: encoder)
        case .event(let v): try v.encode(to: encoder)
        case .unknown(_, let raw):
            var container = encoder.singleValueContainer()
            try container.encode(raw)
        }
    }
";
  return ["public enum GatewayFrame: Codable, Sendable {", ...caseLines, "    case unknown(type: String, raw: [String: AnyCodable])", initLines, "}", ""].join("
");
}
async function generate() {
  const definitions = Object.entries(ProtocolSchemas);
  for (const [name, schema] of definitions) {
    schemaNameByObject.set(schema, name);
  }
  const parts = [];
  parts.push(header);
  for (const [name, schema] of definitions) {
    if ((name === "GatewayFrame")) {
      continue;
    }
    if ((schema.type === "object")) {
      parts.push(emitStruct(name, schema));
    }
  }
  parts.push(emitGatewayFrame());
  const content = parts.join("
");
  for (const outPath of outPaths) {
    await fs.mkdir(path.dirname(outPath), { recursive: true });
    await fs.writeFile(outPath, content);
    console.log("wrote ");
  }
}
generate().catch((err) => {
  console.error(err);
  process.exit(1);
});
